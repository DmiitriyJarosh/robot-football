# Симуляция робофутбола
Была создана с целью практической проверки работоспособности *алгоритма движения*, а также определения лучшего *алгоритма обхода препятствий*.

## Как запустить
```
$ pip3 install numpy pygame
$ python3 planmove.py
```
## Как работает симуляция
* Есть 9 игроков, которые двигаются случайнм образом
* Есть мяч, которого нужно коснуться

## Как происходит движение
0. `target_x` и `target_y` определяют точку, в которую хотим подвинуть робота. Изначально `target_x == x` и `target_y == y` (точка назначения равна точке нахождения робота)
1. ЕСЛИ точка достигнута, ТО вызывается функция `obstacleAvoidance()`, в которой **определяется** и **задается** (возвращается `return`'ом) следующая наиболее подходящая точка назначения.
2. Далее симуляция вызывает функцию `moveToDot()`.
3. Пока точка не будет достигнута, симуляция будет вызывать функцию `moveToDotAgain()`. Когда точка будет достигнута, симуляция снова вызовет функцию `obstacleAvoidance()` для определения следующей точки.

### Проблемы
1. `target_x` и `target_y` не должны быть слишком далеко от робота, иначе просто не получится попасть в нужную точку. **Возможное решение**: "поиграть" с параметрами `k_ro`, `k_alpha`, `k_beta`, `l` и `r`.
2. Алгоритм движения к точке определяет вектор `ksi`, из которого получаем вектор `phi`. Вектор `phi` содержит скорости, которые нужно подать на левое и на парвое колеса робота. Проблема: эти скорости никак не ограничиваются, в то время как у робота есть максимальная допустимая скорость. **Временное решение**: если скорость в векторе больше допустимой, то уменьшаем ее до максимальной допустимой, а скорость на второе колесо выставляем меньшим на то же кол-во процентов, на которое она меньше в векторе.
